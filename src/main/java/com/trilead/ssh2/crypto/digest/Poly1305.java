package com.trilead.ssh2.crypto.digest;

/**
 * Poly1305 one-time authenticator.
 *
 * Implementation based on RFC 8439 (ChaCha20 and Poly1305 for IETF Protocols).
 * This is a public domain algorithm by Daniel J. Bernstein.
 *
 * @author Kenny Root
 */
public class Poly1305 {
	private static final int BLOCK_SIZE = 16;

	// Poly1305 state: accumulator
	private int h0, h1, h2, h3, h4; // Accumulator (136 bits, as 5x27-bit limbs)

	// Poly1305 key: r and s
	private int r0, r1, r2, r3, r4; // R value (clamped)
	private int s0, s1, s2, s3; // S value (pad)

	private byte[] buffer;
	private int bufferPos;
	private boolean finished;

	/**
	 * Initialize Poly1305 with a 32-byte key.
	 *
	 * @param key 32-byte Poly1305 key (typically generated by ChaCha20)
	 */
	public void init(byte[] key) {
		if (key.length != 32) {
			throw new IllegalArgumentException("Poly1305 key must be 32 bytes");
		}

		// Clamp r (first 16 bytes of key)
		// RFC 8439 Section 2.5: certain bits of r must be cleared
		int t0 = readIntLE(key, 0);
		int t1 = readIntLE(key, 4);
		int t2 = readIntLE(key, 8);
		int t3 = readIntLE(key, 12);

		/* r &= 0xffffffc0ffffffc0ffffffc0fffffff */
		r0 = t0 & 0x3ffffff;
		r1 = ((t0 >>> 26) | (t1 << 6)) & 0x3ffff03;
		r2 = ((t1 >>> 20) | (t2 << 12)) & 0x3ffc0ff;
		r3 = ((t2 >>> 14) | (t3 << 18)) & 0x3f03fff;
		r4 = (t3 >>> 8) & 0x00fffff;

		// Load s (second 16 bytes of key)
		s0 = readIntLE(key, 16);
		s1 = readIntLE(key, 20);
		s2 = readIntLE(key, 24);
		s3 = readIntLE(key, 28);

		// Initialize accumulator to zero
		h0 = h1 = h2 = h3 = h4 = 0;

		buffer = new byte[BLOCK_SIZE];
		bufferPos = 0;
		finished = false;
	}

	/**
	 * Update Poly1305 with more data.
	 *
	 * @param data   input data
	 * @param offset offset into data
	 * @param length number of bytes to process
	 */
	public void update(byte[] data, int offset, int length) {
		if (finished) {
			throw new IllegalStateException("Poly1305 already finished");
		}

		int remaining = length;
		int pos = offset;

		// Process buffered data first
		if (bufferPos > 0) {
			int toCopy = Math.min(BLOCK_SIZE - bufferPos, remaining);
			System.arraycopy(data, pos, buffer, bufferPos, toCopy);
			bufferPos += toCopy;
			pos += toCopy;
			remaining -= toCopy;

			if (bufferPos == BLOCK_SIZE) {
				processBlock(buffer, 0, false);
				bufferPos = 0;
			}
		}

		// Process complete blocks
		while (remaining >= BLOCK_SIZE) {
			processBlock(data, pos, false);
			pos += BLOCK_SIZE;
			remaining -= BLOCK_SIZE;
		}

		// Buffer remaining data
		if (remaining > 0) {
			System.arraycopy(data, pos, buffer, 0, remaining);
			bufferPos = remaining;
		}
	}

	/**
	 * Finish Poly1305 and return the 16-byte authentication tag.
	 *
	 * @param tag    output buffer for tag
	 * @param offset offset into output buffer
	 */
	public void finish(byte[] tag, int offset) {
		if (finished) {
			throw new IllegalStateException("Poly1305 already finished");
		}

		// Process final block (possibly partial)
		if (bufferPos > 0) {
			// Add padding byte
			buffer[bufferPos] = 1;
			// Zero out remaining bytes in the block
			for (int i = bufferPos + 1; i < BLOCK_SIZE; i++) {
				buffer[i] = 0;
			}
			// Increment bufferPos to include the padding byte for hibit calculation
			bufferPos++;
			processBlock(buffer, 0, true);
		}

		// Fully reduce h mod (2^130 - 5)
		int g0, g1, g2, g3, g4;
		long c;

		// h + 5
		c = Integer.toUnsignedLong(h0) + 5;
		g0 = (int) c & 0x03ffffff;
		c >>>= 26;
		c += h1;
		g1 = (int) c & 0x03ffffff;
		c >>>= 26;
		c += h2;
		g2 = (int) c & 0x03ffffff;
		c >>>= 26;
		c += h3;
		g3 = (int) c & 0x03ffffff;
		c >>>= 26;
		c += h4;
		g4 = (int) c & 0x03ffffff;
		g4 -= (1 << 26);

		// Select h or g based on overflow
		int mask = -(int) (c >>> 26); // -1 if overflow, 0 if not
		g0 &= mask;
		g1 &= mask;
		g2 &= mask;
		g3 &= mask;
		g4 &= mask;
		mask = ~mask;
		h0 = (h0 & mask) | g0;
		h1 = (h1 & mask) | g1;
		h2 = (h2 & mask) | g2;
		h3 = (h3 & mask) | g3;
		h4 = (h4 & mask) | g4;

		// h = h mod 2^128
		h0 = h0 | (h1 << 26);
		h1 = (h1 >>> 6) | (h2 << 20);
		h2 = (h2 >>> 12) | (h3 << 14);
		h3 = (h3 >>> 18) | (h4 << 8);

		// h = (h + s) mod 2^128
		c = Integer.toUnsignedLong(h0) + Integer.toUnsignedLong(s0);
		h0 = (int) c;
		c = Integer.toUnsignedLong(h1) + Integer.toUnsignedLong(s1) + (c >>> 32);
		h1 = (int) c;
		c = Integer.toUnsignedLong(h2) + Integer.toUnsignedLong(s2) + (c >>> 32);
		h2 = (int) c;
		c = Integer.toUnsignedLong(h3) + Integer.toUnsignedLong(s3) + (c >>> 32);
		h3 = (int) c;

		// Output as little-endian
		writeIntLE(h0, tag, offset);
		writeIntLE(h1, tag, offset + 4);
		writeIntLE(h2, tag, offset + 8);
		writeIntLE(h3, tag, offset + 12);

		finished = true;

		// Wipe sensitive state after finish
		reset();
	}

	/**
	 * Reset and wipe all sensitive state data.
	 * Should be called after finish() or when the instance is no longer needed.
	 */
	public void reset() {
		// Wipe key material
		r0 = r1 = r2 = r3 = r4 = 0;
		s0 = s1 = s2 = s3 = 0;

		// Wipe accumulator
		h0 = h1 = h2 = h3 = h4 = 0;

		// Wipe buffer
		if (buffer != null) {
			java.util.Arrays.fill(buffer, (byte) 0);
		}

		bufferPos = 0;
	}

	private void processBlock(byte[] block, int offset, boolean isFinal) {
		// Read block as little-endian
		int t0 = readIntLE(block, offset);
		int t1 = readIntLE(block, offset + 4);
		int t2 = readIntLE(block, offset + 8);
		int t3 = readIntLE(block, offset + 12);

		// Add to accumulator with high bit (unless final partial block)
		int hibit = isFinal && bufferPos < BLOCK_SIZE ? 0 : (1 << 24);

		long d0 = Integer.toUnsignedLong(h0) + (t0 & 0x03ffffffL);
		long d1 = Integer.toUnsignedLong(h1) + (((t0 >>> 26) | (t1 << 6)) & 0x03ffffffL);
		long d2 = Integer.toUnsignedLong(h2) + (((t1 >>> 20) | (t2 << 12)) & 0x03ffffffL);
		long d3 = Integer.toUnsignedLong(h3) + (((t2 >>> 14) | (t3 << 18)) & 0x03ffffffL);
		long d4 = Integer.toUnsignedLong(h4) + ((t3 >>> 8) | hibit);

		// Multiply by r
		long c = 0;
		long r0Long = r0 & 0xffffffffL;
		long r1Long = r1 & 0xffffffffL;
		long r2Long = r2 & 0xffffffffL;
		long r3Long = r3 & 0xffffffffL;
		long r4Long = r4 & 0xffffffffL;

		c = d0 * r0Long;
		c += d1 * (r4Long * 5);
		c += d2 * (r3Long * 5);
		c += d3 * (r2Long * 5);
		c += d4 * (r1Long * 5);
		h0 = (int) c & 0x03ffffff;
		c >>>= 26;

		c += d0 * r1Long;
		c += d1 * r0Long;
		c += d2 * (r4Long * 5);
		c += d3 * (r3Long * 5);
		c += d4 * (r2Long * 5);
		h1 = (int) c & 0x03ffffff;
		c >>>= 26;

		c += d0 * r2Long;
		c += d1 * r1Long;
		c += d2 * r0Long;
		c += d3 * (r4Long * 5);
		c += d4 * (r3Long * 5);
		h2 = (int) c & 0x03ffffff;
		c >>>= 26;

		c += d0 * r3Long;
		c += d1 * r2Long;
		c += d2 * r1Long;
		c += d3 * r0Long;
		c += d4 * (r4Long * 5);
		h3 = (int) c & 0x03ffffff;
		c >>>= 26;

		c += d0 * r4Long;
		c += d1 * r3Long;
		c += d2 * r2Long;
		c += d3 * r1Long;
		c += d4 * r0Long;
		h4 = (int) c & 0x03ffffff;
		c >>>= 26;

		h0 += (int) (c * 5);
		h1 += h0 >>> 26;
		h0 &= 0x03ffffff;
	}

	private static int readIntLE(byte[] buf, int offset) {
		return (buf[offset] & 0xff) |
				((buf[offset + 1] & 0xff) << 8) |
				((buf[offset + 2] & 0xff) << 16) |
				((buf[offset + 3] & 0xff) << 24);
	}

	private static void writeIntLE(int value, byte[] buf, int offset) {
		buf[offset] = (byte) value;
		buf[offset + 1] = (byte) (value >>> 8);
		buf[offset + 2] = (byte) (value >>> 16);
		buf[offset + 3] = (byte) (value >>> 24);
	}
}
